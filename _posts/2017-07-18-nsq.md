---
title: NSQ
author: Noodles
layout: post
permalink: /2017/07/nsq
categories:
  - tools
tags:
  - nsq
  
---

<!--more-->

 ---------------------------------------------------

#### NSQ简介

  NSQ是google开发，用go实现的消息队列服务。NSQ具有以下特性：
 - 分布式并且高可用，消除单点故障。
 - 保证消息可靠的分发。
 - 无需担心消息过多时一直占用内存： 如有必要将消息写入磁盘。
 - 对生产侧和消费侧配置极为简单


##### 简单的配置与管理

  `nsqd`实例一次性可以处理多个数据流。数据流又被称为"topics"。
  一个topic可同时拥有一个或多个"channels"。每个channel都从与之相关的topic接收所有消息的副本。
  在实践中，一个channel映射到一个消费这个主题的下游服务。

  topic和channel没有优先级。当第一次发布或者订阅一个命名的topic时，这个topic被就被创建。
  当订阅一个命名的channel时，这个channel就被创建。

  topic和channel都是各自独立的缓存数据，避免慢消费者造成其他channel堵塞。

  一个channel能够而且通常也是这样做的： 一个channel可通常与多个client建立连接。假如所有与之连接的
  client都处在等待接受消息的状态时，那么这个channel流出的每条消息都会随机流向一个client。

  总结来说，多个topic产生各种消息，每个channel从topic中接收所有消息的副本；最后，每个消费者从这个
  channel中接收部分消息。

  NSQ有一个辅助程序——`nsqlookupd`。这个程序为消费者提供服务发现服务：它供消费者查找提供它们感兴趣
  的topic的`nsqd`实例所在的地址。这样做的好处是它解耦了生产者与消费者(二者都只需要知道与共同的nsqlookup
  建立连接，而不需要两者之间直接建立联系)，减少了复杂的维护。

  每个nsqd实例底层都与nsqlookupd建立一个tcp长连接，用来周期性的将自身的状态报告给nsqlookupd。
