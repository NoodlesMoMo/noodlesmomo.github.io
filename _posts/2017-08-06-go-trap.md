---
title: golang traps and pitfalls
author: Noodles
layout: post
permalink: /2017/08/golang_traps
categories:
  - lanuage
tags:
  - go
  
---

<!--more-->

 ---------------------------------------------------

### 迭代、作用域、lazy call

  考虑这样一个问题：你被要求首先创建一些目录，再将目录删除。以下代码值得我们好好讨论：

  {% highlight go %}
  var rmdirs []func()
  for _, d := range tempDirs(){
    dir := d // NOTE: necessary
    os.MkdirAll(dir, 0755)
    rmdirs = append(rmdirs, func(){
        os.RemoveAll(dir)
    })
  }

  // Do sometings ...

  // remove dirs
  for _, rmdir := range rmdirs{
    rmdir()    
  }

  {% endhighlight %}

  你可能感到很困惑，为什么要在循环体中用循环变量d赋值一个新的局部变量。
  如果删除那句看似很多余的`dir := d`局部变量创建赋值语句则程序是错误的。
  在上面的程序中，for循环引入了新的词法块，循环变量dir在这个词法块中被
  声明。在该循环中生成的所有函数值都共享相同的循环变量。需要注意的是，
  函数值中记录的是循环变量的内存地址，而不是循环变量某一时刻的值。以dir
  为例，后续的迭代会不断更新dir的值，当删除操作执行时，for循环已经完成，
  dir中存储的值等于最后一次迭代的值，这意味着，每次对os.RemoveAll的调用
  删除的都是相同的目录。

  通常，为了解决这类问题，我们会引入一个与循环变量同名的局部变量，作为循环
  变量的副本。这虽然看起来很奇怪，但却很有用：
  {% highlight go %}
  for _, dir := range tempDirs(){
      dir := dir // declares inner dir, initialized to outer dir
  }
  {% endhighlight %}

  这个问题不仅局限在range循环，下面这段存在同样问题：

  {% highlight go %}
  var rmdirs []func()
  dirs := tempDirs()
  for i:=0; i<len(dirs); i++{
      os.MkdirAll(dirs[i], 0755) // OK
      rmdirs = append(rmdirs, func(){
          os.RemoveAll(dirs[i]) // FIXEME: incorrect!!!
    })
  }
  {% endhighlight %}

### for 遇到 defer
  
  在循环体中的defer语句需要特别注意，因为只有在函数执行完毕后，这些延迟函数才会执行。
  下面的代码会导致系统的文件描述符耗尽： 因为在所有文件都被处理之前，没有文件会被关闭。
  {% highlight go %}
    for _, filename := range filenames{
        f, err := os.Open(filename)
        if err != nil{
            return err
        }
        defer f.Close() // NOTE: risky; could run out of the file descriptors

        // do something
    }
  {% endhighlight %}

  一种解决方法是将循环体中的defer语句移至另一个函数。每次循环时，调用这个函数。

  {% highlight go %}
    for _, filename := range filenames{
        if err := doFile(filename); err != nil{
            return err    
        }
    }

    func doFile(filename string) error{
        f, err := os.Open(filename)
        if err != nil{
            return err
        }
        defer f.Close()
        // ...
    }
  {% endhighlight %}

### *p++
  *p++ 在c/c++中，`++`运算符的优先级高于`*`, 因此先执行++，指针地址偏移所指数据类型个字节位置，由于后缀++的先使用后生效特点，整体表现为先取p位置数据，然后指针+1。
  而在go中，*p++只对p所指地址的数据进行`++`运算。
  
  **个人以为，go采取这样的行为一是为了使语法更加简单而且明确; 
  二是go包含垃圾回收，如果++运算符作用到p会给GC的实现造成复杂**
  
  {% highlight go %}
    func incr(p *int) int{
        *p++ // NOTE: 只是增加p指向的变量的值，并不改变p指针
        return *p
    }

    v := 1
    incr(&v)    // sizd effect: v is now 2
    fmt.Println(incr(&v)) // print 3
  {% endhighlight %}

